using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using TCX.Configuration;
using OMSamples;
using TCX.Configuration.Exceptions;
using System.Xml.Linq;
using System.Diagnostics.CodeAnalysis;

namespace OMSamples.Samples
{
    [SampleCode("playlists")]
    [SampleAction("list|<empty parameter list>", "")]
    [SampleAction("create", "name=AudioFeed.Name source=AudioFeed.Source [autogain=true|false] [shuffle|sorted] [volume=0..100] [stopempty=true|false]")]
    [SampleAction("update", "[name=AudioFeed.Name]|[source=AudioFeed.Source] [autogain=true|false] [shuffle|sorted] [volume=0..100] [stopempty=true|false]")]
    [SampleAction("delete", "[name=AudioFeed.Name] [source=AudioFeed.Source]")]
    [SampleDescription("prints, updates, creates, deletes playlists definitions. name source is the selector in update|delete. create - source is autogenerated if not specified. autogain set to false shuffle=false")]

    class PlayListsSample : ISample
    {
        string[] MOHParameters =
        {
        "MUSICONHOLDFILE",
        "MUSICONHOLDFILE1",
        "MUSICONHOLDFILE2",
        "MUSICONHOLDFILE3",
        "MUSICONHOLDFILE4",
        "MUSICONHOLDFILE5",
        "MUSICONHOLDFILE6",
        "MUSICONHOLDFILE7",
        "MUSICONHOLDFILE8",
        "MUSICONHOLDFILE9",
        "CONFPLACE_MOH_SOURCE",
        "IVR_MOH_SOURCE",
        "PARK_MOH_SOURCE"
        };
        public void Run(PhoneSystem ps, string action, Dictionary<string, string> args)
        {
            var playlists_folder = ps.GetParameterValue("IVRPROMPTPATH") + "/Playlist";
            using (var all_playlists = ps.GetAllAudioFeeds().GetDisposer())
            {
                if (string.IsNullOrEmpty(action)||action.Equals("list")) //no parameters. display all playlists
                {
                    var playlists = all_playlists.Value
                        .Where(x => x.Type == AudioFeedType.FolderRandomFeed || x.Type == AudioFeedType.FolderSortedFeed)
                        .ToDictionary(x => x.Source);

                    var configured_folders = new HashSet<string>(playlists.Keys);
                    var all_folders = new HashSet<string>(Directory.EnumerateDirectories(playlists_folder).Select(x => Path.GetFileName(x)));

                    var playlists_with_folders = configured_folders.Intersect(all_folders).ToArray();
                    var folders_without_playlist = all_folders.Except(configured_folders).ToArray();
                    try
                    {
                        foreach (var a in playlists)
                        {
                            bool folder_exists = playlists_with_folders.Contains(a.Value.Source);
                            if (folder_exists)
                            {
                                //properly configured playlists
                                Console.ForegroundColor = ConsoleColor.Green;
                            }
                            else
                            {
                                Console.ForegroundColor = ConsoleColor.Red; //misconfigured
                            }
                            Console.WriteLine("Name={0}, Source={1}, Shuffle={2}, AutoGain={3}, MaxVolume={4}% NoNStop={5}:\n{{\n\t{6}\n}}",
                                a.Value.Name, //{0]
                                a.Value.Source, //{1}
                                a.Value.Type == AudioFeedType.FolderRandomFeed,//{2}
                                a.Value.AutoGain,//{3}
                                a.Value.MaxVolume,//{4}
                                a.Value.NoPauseIfEmpty, //{5}
                                folder_exists ? string.Join("\n\t", Directory.EnumerateFiles(playlists_folder + "/" + a.Value.Source).ToArray()) : ""//{6}
                                );
                        }
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("Other folders:\n{0}",
                            string.Join("\t\n", folders_without_playlist.ToArray())
                            );
                    }
                    finally
                    {
                        Console.ResetColor();
                    }
                    return;
                }

                args.TryGetValue("name", out var name);
                args.TryGetValue("source", out var source);

                var theFeed = (action, name, source) switch
                {
                    ("create", not null, _)
                        => ps.GetAll<AudioFeed>().ExtractFirstOrDefault(x => x.Name == name) == null ? ps.CreateAudioFeed() : throw new ObjectAlreadyExistsException($"Name={name}"),
                    ("create", _, not null)
                        => ps.GetAll<AudioFeed>().ExtractFirstOrDefault(x => x.Source == source) == null? ps.CreateAudioFeed() : throw new ObjectAlreadyExistsException($"Source={source}"),
                    ("update" or "delete", not null, _) =>
                        ps.GetAll<AudioFeed>().ExtractFirstOrDefault(x => x.Name == name) ?? throw new Exception($"Name={name} is not found"),
                    ("update" or "delete", _, not null) => ps.GetAll<AudioFeed>().ExtractFirstOrDefault(x => x.Name == source) ?? throw new Exception($"Source={source} is not found"),
                    (_,_,_)=>throw new Exception("unknown action or insufficient parameter set")
                };
                switch (action)
                {
                    case "create":
                        {
                            theFeed.Source = source ?? name;
                            theFeed.Name = name ?? source;
                            theFeed.Type = args.TryGetValue("sorted", out var _) ? AudioFeedType.FolderSortedFeed :
                                args.TryGetValue("shuffle", out var _) ? AudioFeedType.FolderRandomFeed : AudioFeedType.FolderSortedFeed;
                            theFeed.MaxVolume = int.TryParse(args.TryGetValue("volume", out var volume) ? volume :"100", out var MaxVolume)?
                                MaxVolume: 100;
                            theFeed.AutoGain = bool.TryParse(args.TryGetValue("autogain", out var value)?value:"false", out var boolvalue)? boolvalue : false;
                            theFeed.NoPauseIfEmpty = bool.TryParse(args.TryGetValue("autogain", out value) ? value : "false", out boolvalue) ? boolvalue : false;
                        }
                        break;
                    case "update":
                        {
                            //name is not updated
                            if (source != null)
                                theFeed.Source = source;
                            if (args.TryGetValue("autogain", out var value) && bool.TryParse(value, out var boolvalue))
                                theFeed.AutoGain = boolvalue;
                            if (args.TryGetValue("shuffle", out value))
                                theFeed.Type = AudioFeedType.FolderRandomFeed;
                            if (args.TryGetValue("sorted", out value))
                                theFeed.Type = AudioFeedType.FolderSortedFeed;
                            if (args.TryGetValue("volume", out value) && int.TryParse(value, out var intvolume)&&intvolume>=0&&intvolume<=100)
                                theFeed.MaxVolume = intvolume;
                            if (args.TryGetValue("stopempty", out value)&& bool.TryParse(value, out boolvalue))
                                theFeed.NoPauseIfEmpty= !boolvalue;
                        }
                        break;
                    case "delete":
                        {
                        //verification:
                        //check all parameters and objects where references can exist
                        var reference = @"\\.\pipe\" + name;
                        var paramReferences = MOHParameters.Where(x => ps.GetParameterValue(x) == reference);
                        using (var queues = ps.GetAll<Queue>().GetDisposer().Extract(y => y.OnHoldFile == reference))
                        {
                            if (paramReferences.Any() || queues.Any())
                            {
                                Console.WriteLine($"Cannot delete Playlist{theFeed.Source} because it is referenced by :");
                                foreach (var a in paramReferences)
                                {
                                    Console.WriteLine($"\tPARAMETER: {a}");
                                }
                                foreach (var a in queues)
                                {
                                    Console.WriteLine($"\tQUEUE: {a.Number}");
                                }
                            }
                            else
                            {
                                //does not remove folder.
                                theFeed.Delete();
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
}